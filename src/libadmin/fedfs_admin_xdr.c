/*
 * Please do not edit this file.
 * It was generated using rpcgen.
 */

#include "fedfs_admin.h"

bool_t
xdr_FedFsStatus (XDR *xdrs, FedFsStatus *objp)
{
	register int32_t *buf;

	 if (!xdr_enum (xdrs, (enum_t *) objp))
		 return FALSE;
	return TRUE;
}

bool_t
xdr_utf8string (XDR *xdrs, utf8string *objp)
{
	register int32_t *buf;

	 if (!xdr_bytes (xdrs, (char **)&objp->utf8string_val, (u_int *) &objp->utf8string_len, ~0))
		 return FALSE;
	return TRUE;
}

bool_t
xdr_ascii_REQUIRED4 (XDR *xdrs, ascii_REQUIRED4 *objp)
{
	register int32_t *buf;

	 if (!xdr_utf8string (xdrs, objp))
		 return FALSE;
	return TRUE;
}

bool_t
xdr_utf8val_REQUIRED4 (XDR *xdrs, utf8val_REQUIRED4 *objp)
{
	register int32_t *buf;

	 if (!xdr_utf8string (xdrs, objp))
		 return FALSE;
	return TRUE;
}

bool_t
xdr_FedFsUuid (XDR *xdrs, FedFsUuid objp)
{
	register int32_t *buf;

	 if (!xdr_opaque (xdrs, objp, 16))
		 return FALSE;
	return TRUE;
}

bool_t
xdr_FedFsNsdbName (XDR *xdrs, FedFsNsdbName *objp)
{
	register int32_t *buf;

	 if (!xdr_u_int (xdrs, &objp->port))
		 return FALSE;
	 if (!xdr_utf8val_REQUIRED4 (xdrs, &objp->hostname))
		 return FALSE;
	return TRUE;
}

bool_t
xdr_FedFsPathComponent (XDR *xdrs, FedFsPathComponent *objp)
{
	register int32_t *buf;

	 if (!xdr_ascii_REQUIRED4 (xdrs, objp))
		 return FALSE;
	return TRUE;
}

bool_t
xdr_FedFsPathName (XDR *xdrs, FedFsPathName *objp)
{
	register int32_t *buf;

	 if (!xdr_array (xdrs, (char **)&objp->FedFsPathName_val, (u_int *) &objp->FedFsPathName_len, ~0,
		sizeof (FedFsPathComponent), (xdrproc_t) xdr_FedFsPathComponent))
		 return FALSE;
	return TRUE;
}

bool_t
xdr_FedFsFsn (XDR *xdrs, FedFsFsn *objp)
{
	register int32_t *buf;

	 if (!xdr_FedFsUuid (xdrs, objp->fsnUuid))
		 return FALSE;
	 if (!xdr_FedFsNsdbName (xdrs, &objp->nsdbName))
		 return FALSE;
	return TRUE;
}

bool_t
xdr_FedFsFslType (XDR *xdrs, FedFsFslType *objp)
{
	register int32_t *buf;

	 if (!xdr_enum (xdrs, (enum_t *) objp))
		 return FALSE;
	return TRUE;
}

bool_t
xdr_FedFsNfsFsl (XDR *xdrs, FedFsNfsFsl *objp)
{
	register int32_t *buf;

	 if (!xdr_FedFsUuid (xdrs, objp->fslUuid))
		 return FALSE;
	 if (!xdr_u_int (xdrs, &objp->port))
		 return FALSE;
	 if (!xdr_utf8val_REQUIRED4 (xdrs, &objp->hostname))
		 return FALSE;
	 if (!xdr_FedFsPathName (xdrs, &objp->path))
		 return FALSE;
	return TRUE;
}

bool_t
xdr_FedFsFsl (XDR *xdrs, FedFsFsl *objp)
{
	register int32_t *buf;

	 if (!xdr_FedFsFslType (xdrs, &objp->type))
		 return FALSE;
	switch (objp->type) {
	case FEDFS_NFS_FSL:
		 if (!xdr_FedFsNfsFsl (xdrs, &objp->FedFsFsl_u.nfsFsl))
			 return FALSE;
		break;
	default:
		return FALSE;
	}
	return TRUE;
}

bool_t
xdr_FedFsPathType (XDR *xdrs, FedFsPathType *objp)
{
	register int32_t *buf;

	 if (!xdr_enum (xdrs, (enum_t *) objp))
		 return FALSE;
	return TRUE;
}

bool_t
xdr_FedFsPath (XDR *xdrs, FedFsPath *objp)
{
	register int32_t *buf;

	 if (!xdr_FedFsPathType (xdrs, &objp->type))
		 return FALSE;
	switch (objp->type) {
	case FEDFS_PATH_SYS:
		 if (!xdr_FedFsPathName (xdrs, &objp->FedFsPath_u.adminPath))
			 return FALSE;
		break;
	case FEDFS_PATH_NFS:
		 if (!xdr_FedFsPathName (xdrs, &objp->FedFsPath_u.nfsPath))
			 return FALSE;
		break;
	default:
		return FALSE;
	}
	return TRUE;
}

bool_t
xdr_FedFsCreateArgs (XDR *xdrs, FedFsCreateArgs *objp)
{
	register int32_t *buf;

	 if (!xdr_FedFsPath (xdrs, &objp->path))
		 return FALSE;
	 if (!xdr_FedFsFsn (xdrs, &objp->fsn))
		 return FALSE;
	return TRUE;
}

bool_t
xdr_FedFsResolveType (XDR *xdrs, FedFsResolveType *objp)
{
	register int32_t *buf;

	 if (!xdr_enum (xdrs, (enum_t *) objp))
		 return FALSE;
	return TRUE;
}

bool_t
xdr_FedFsLookupArgs (XDR *xdrs, FedFsLookupArgs *objp)
{
	register int32_t *buf;

	 if (!xdr_FedFsPath (xdrs, &objp->path))
		 return FALSE;
	 if (!xdr_FedFsResolveType (xdrs, &objp->resolve))
		 return FALSE;
	return TRUE;
}

bool_t
xdr_FedFsLookupResOk (XDR *xdrs, FedFsLookupResOk *objp)
{
	register int32_t *buf;

	 if (!xdr_FedFsFsn (xdrs, &objp->fsn))
		 return FALSE;
	 if (!xdr_array (xdrs, (char **)&objp->fsl.fsl_val, (u_int *) &objp->fsl.fsl_len, ~0,
		sizeof (FedFsFsl), (xdrproc_t) xdr_FedFsFsl))
		 return FALSE;
	return TRUE;
}

bool_t
xdr_FedFsLookupResReferralVal (XDR *xdrs, FedFsLookupResReferralVal *objp)
{
	register int32_t *buf;

	 if (!xdr_FedFsNsdbName (xdrs, &objp->targetNsdb))
		 return FALSE;
	 if (!xdr_u_int (xdrs, &objp->ldapResultCode))
		 return FALSE;
	return TRUE;
}

bool_t
xdr_FedFsLookupRes (XDR *xdrs, FedFsLookupRes *objp)
{
	register int32_t *buf;

	 if (!xdr_FedFsStatus (xdrs, &objp->status))
		 return FALSE;
	switch (objp->status) {
	case FEDFS_OK:
	case FEDFS_ERR_NO_CACHE_UPDATE:
		 if (!xdr_FedFsLookupResOk (xdrs, &objp->FedFsLookupRes_u.resok))
			 return FALSE;
		break;
	case FEDFS_ERR_NSDB_LDAP_VAL:
		 if (!xdr_u_int (xdrs, &objp->FedFsLookupRes_u.ldapResultCode))
			 return FALSE;
		break;
	case FEDFS_ERR_NSDB_LDAP_REFERRAL:
	case FEDFS_ERR_NSDB_PARAMS_LDAP_REFERRAL:
		 if (!xdr_FedFsNsdbName (xdrs, &objp->FedFsLookupRes_u.targetNsdb))
			 return FALSE;
		break;
	case FEDFS_ERR_NSDB_LDAP_REFERRAL_VAL:
		 if (!xdr_FedFsLookupResReferralVal (xdrs, &objp->FedFsLookupRes_u.resReferralVal))
			 return FALSE;
		break;
	default:
		break;
	}
	return TRUE;
}

bool_t
xdr_FedFsConnectionSec (XDR *xdrs, FedFsConnectionSec *objp)
{
	register int32_t *buf;

	 if (!xdr_enum (xdrs, (enum_t *) objp))
		 return FALSE;
	return TRUE;
}

bool_t
xdr_FedFsNsdbParams (XDR *xdrs, FedFsNsdbParams *objp)
{
	register int32_t *buf;

	 if (!xdr_FedFsConnectionSec (xdrs, &objp->secType))
		 return FALSE;
	switch (objp->secType) {
	case FEDFS_SEC_TLS:
		 if (!xdr_bytes (xdrs, (char **)&objp->FedFsNsdbParams_u.secData.secData_val, (u_int *) &objp->FedFsNsdbParams_u.secData.secData_len, ~0))
			 return FALSE;
		break;
	default:
		break;
	}
	return TRUE;
}

bool_t
xdr_FedFsSetNsdbParamsArgs (XDR *xdrs, FedFsSetNsdbParamsArgs *objp)
{
	register int32_t *buf;

	 if (!xdr_FedFsNsdbName (xdrs, &objp->nsdbName))
		 return FALSE;
	 if (!xdr_FedFsNsdbParams (xdrs, &objp->params))
		 return FALSE;
	return TRUE;
}

bool_t
xdr_FedFsGetNsdbParamsRes (XDR *xdrs, FedFsGetNsdbParamsRes *objp)
{
	register int32_t *buf;

	 if (!xdr_FedFsStatus (xdrs, &objp->status))
		 return FALSE;
	switch (objp->status) {
	case FEDFS_OK:
		 if (!xdr_FedFsNsdbParams (xdrs, &objp->FedFsGetNsdbParamsRes_u.params))
			 return FALSE;
		break;
	default:
		break;
	}
	return TRUE;
}

bool_t
xdr_FedFsGetLimitedNsdbParamsRes (XDR *xdrs, FedFsGetLimitedNsdbParamsRes *objp)
{
	register int32_t *buf;

	 if (!xdr_FedFsStatus (xdrs, &objp->status))
		 return FALSE;
	switch (objp->status) {
	case FEDFS_OK:
		 if (!xdr_FedFsConnectionSec (xdrs, &objp->FedFsGetLimitedNsdbParamsRes_u.secType))
			 return FALSE;
		break;
	default:
		break;
	}
	return TRUE;
}
#define FEDFS_ADMIN_X
